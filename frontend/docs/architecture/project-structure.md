# Project Structure

Explains:
- What each folder is for
- How is new code written
- Where new code should live

---

## Root directories

### `config/`
Centralized, non-runtime configuration:
- **`config/test/`** – Vitest / RTL bootstrap & globals.
- **`config/ts/`** – All TS configs (app, eslint, node). Keep `tsconfig.json` at root minimal.

### `docker/`
- Everything Docker-related (local dev images, compose files, etc.).

### `docs/`
- All project documentation (what you’re reading now), split by topics.

### `public/`
- Static files copied as-is to the final build (e.g., `/images/logo.png`).

### `src/`
- **All application code.** See the next section for how it’s organized.

### Root files
- `eslint.config.js` – ESLint flat config.
- `vite.config.ts` – Vite build/dev config.
- `vitest.config.ts` – Vitest config (multi-project supported).
- `tsconfig.json` – Root TS config (delegates to `config/ts/*`).
- `package.json`, `pnpm-lock.yaml` – Dependencies & scripts.

---

## Inside `src/`

### `api/`
- Lowest-level API surface and **shared API-level types**.
- Keep it **thin**. Domain logic belongs in `services/` or in feature/page modules.

### `services/`
- Domain/service layer, interface for communicating with APIs.
- Own the business logic, request/response normalization, and domain-specific types/enums.

### `queries/`
- **TanStack Query** code: keys, query/mutation hooks, related types.
- Shared query keys under `queries/keys/*` keep cache access consistent and typed.

### `routes/`
- **TanStack Router** route files. Co-locate by route segment.
- `routes-tree.gen.ts` (in root of `src/`) is generated by the router plugin — don’t edit it.

### `pages/`
- **Screen-level** components and their local contexts/components.
- For now, every page is mapped one-to-one on `/routes` folder.

### `components/`
Reusable UI building blocks for the entire app:
- `ui/` – atomic primitives (Input, Button, Select, Tooltip, etc.).
- `form/` – React hook form bound components, controlled form fields etc.
- `layouts/` – app shells, navbars, sidebars.

### `contexts/`
- Global contexts (auth, theme, etc.).
- Feature- or page-only contexts should live alongside their feature/page.

### `hooks/`
- Reusable cross-feature hooks (e.g., `use-mobile`, `use-loading`).
- Feature-specific hooks stay **with the feature/page**.

### `styles/`
- Global CSS, Tailwind entrypoint.

### `features/`
- **Feature-first organization** by business domain and capability.
- Self-contained user workflows with their own components, hooks, forms, and utilities.
- Structure: `features/{domain}/{feature-name}/` (e.g., `features/workspaces/create-workspace-modal/`).
- Features consume shared services and components but don't import from other features.

### `utils/`
- Generic helpers & small libraries (css helpers, URL utils, cookies, etc.).
- Co-locate their own `types/` and `enums/` folders inside each util area if needed.

### `app.tsx` / `main.tsx`
- The app shell and the root bootstrap (providers, mounting, etc.).

---

## Where should my new code go?

Use this quick checklist (architectural layers):

1. **Is it reusable UI/utilities across domains?**
   → `components/`, `hooks/`, `utils/`.
2. **Is it domain/business logic?**
   → `services/<domain>/<subdomain if needed>`.
3. **Is it about fetching/mutating server state?**
   → `queries/` (define query keys + wrappers).
4. **Is it a complete user workflow or business capability?**
   → `features/{domain}/{feature-name}/`.
5. **Is it screen-specific UI?**
   → `pages/<page>/`.
6. **Is it global app wiring (providers/router/theme)?**
   → `app.tsx`, `contexts/`, `routes/`.
7. **Is it a new tool/config/script at the project root (e.g., new linter, CI step, build tool, Docker/Compose, TS/Vite config changes etc.)?**
   → **Consult with the maintainers first** to avoid fragmentation and ensure team-wide alignment, and update the docs accordingly.
